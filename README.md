# 设计模式七大原则
## 开闭原则
- 开放扩展、关闭修改
- 通过抽象构建框架、通过实现扩展细节
> 核心思想：面向抽象编程，抽象相对稳定，实现相对灵活多变。
## 依赖导致原则
- 高层模块不依赖于底层模块、二者共同依赖于抽象
- 抽象不应该依赖细节，细节应该依赖抽象
- 针对接口编程，而不是针对实现编程
## 单一职责原则
- 不要存在多于一个导致类变更的原因
- 一个类、接口、方法等，只负责一项职责
## 接口隔离原则
- 使用多个独立的接口，不使用单一的总接口，客户端不应该依赖他不使用的接口
- 类对类的依赖应该建立在最小的接口上
- 尽量细化接口，接口中的方法尽量少
> 需要适度
## 迪米特原则（最少知道原则）
- 一个对象应对其他对象保持最少的了解（之和朋友交流，不和陌生人说话）
- 尽量降低类与类之间的耦合
- 尽量使用private、protected、package访问控制符
## 里氏替换原则
- 所有引用基类的地方必须能透明地使用其子类的对象，子类对象必须能够替换掉所有父类对象，而程序逻辑不变
## 合成复用原则
- 尽量使用合成/聚合的方式，而不是使用继承来达到软件复用的目的
# 设计模式
## 创建型
### 工厂模式
- 简单工厂不属于23种标准的设计模式中的一种，通过传递type，创建对应的对象。
- 工厂方法将对象的创建推迟到子类，不同的子类负责创建不同类型的对象。抽象方法：创建同一产品等级的对象。[工厂方法](src/main/java/creation/factory/factoryMethod)
- 抽象工厂提供 创建一系列相关或相互依赖的对象 的接口。[抽象工厂](src/main/java/creation/factory/abstraceFactory)
### 建造者模式
- 将复杂对象的创建和表示相分离，使得同样的构建过程可以创建不同的表示。
- 适用于非常复杂的内部结构（有很多属性）、想把创建和使用分离[建造者模式](src/main/java/creation/builder)
### 单例模式
- 确保某一个类只有一个实例，并提供一个访问它的全局访问点。
- 常用于配置、数据库连接池、缓存等。
- 重点：私有构造、线程安全、延迟加载、序列化与反序列化的安全、需要考虑反射攻击
1. 懒汉式
   - 使用的时候在进行初始化
   - 可以通过类锁、DCL的机制保证单例
   - 需要使用volatile修饰，因为可能会发生指令重排序（即：分配内存->返回引用->初始化）
2. 饿汉式
   - 类加载的时候进行初始化
3. 使用枚举类型定义，[反编译](src/main/java/creation/singleton/padfile/EnumInstance.jad)后可以发现：
   - 枚举类的构造方法私有化
   - 通过饿汉式创建实例对象，避免了多线程带来的问题。
   - 反射天生不支持枚举类的构造来创建对象，反序列化类对枚举也有很好的支持。
4. 定义线程安全的map，将创建好的对象放置在map中，通过key获取对象。
5. 基于ThreadLocal实现的单例，只能在线程内保持唯一。
#### 对单例模式的攻击手段
1. 序列化后通过反序列化手段反复创建。可以通过在反序列化过程中，重写readResolve方法返回单例对象来避免。
2. 通过反射手段重复创建对象。可以通过在构造器中判断是否已经创建对象，如果是则抛出异常，此方法仅对饿汉式有效。
### 原型模式
- 通过拷贝原型对象创建新对象
- 比new方式性能更高
- 需要实现Cloneable接口，重写clone方法
## 结构型
### 外观模式
- 又称门面模式，提供一个统一的接口，用来访问子系统中的一群接口。
- 定义一个高层接口，让子系统更容易使用。
- 当系统越来越复杂时，可以简化层间的调用。 符合迪米特法则
### 装饰者模式
- 不改变原有对象的基础上，将功能附加到对象上。
- 提供了比继承更有弹性的代替方案。
- 扩展一个类的功能或给一个类添加附加职责，动态的给一个对象添加功能，这些功能可以撤销。
- 